trigger: none
pr: none

parameters:
  - name: env
    displayName: Environment
    type: string
    default: prod
    values:
      - nonprod
      - prod

variables:
  AWS_REGION: eu-north-1
  AWS_SERVICE_CONNECTION: AWS
  ENV: ${{ parameters.env }}

pool:
  vmImage: ubuntu-latest

steps:
  - checkout: self

  # ----------------------------
  # Install AWS CLI, kubectl, Helm
  # ----------------------------
  - task: Bash@3
    displayName: Install AWS CLI, kubectl, Helm
    inputs:
      targetType: inline
      script: |
        set -euo pipefail

        if ! command -v aws &> /dev/null; then
          curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
          unzip -q awscliv2.zip
          sudo ./aws/install --update
        fi
        aws --version

        curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        kubectl version --client

        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        helm version

  # ----------------------------
  # Setup kubeconfig (PROD / NONPROD)
  # ----------------------------
  - task: AWSShellScript@1
    displayName: Setup EKS kubeconfig
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail

        CLUSTER_NAME="${ENV}-eks"
        echo "Using cluster: $CLUSTER_NAME"

        aws eks update-kubeconfig \
          --region $(AWS_REGION) \
          --name "$CLUSTER_NAME"

        kubectl get nodes

  # ----------------------------
  # Add Helm repos
  # ----------------------------
  - task: AWSShellScript@1
    displayName: Add Helm repos
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo add argo https://argoproj.github.io/argo-helm
        helm repo update

  # ----------------------------
  # Install NGINX Ingress Controller
  # ----------------------------
  - task: AWSShellScript@1
    displayName: Install NGINX Ingress Controller
    inputs:
      awsCredentials: $(AWS_SERVICE_CONNECTION)
      regionName: $(AWS_REGION)
      scriptType: inline
      inlineScript: |
        set -euo pipefail

        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          --namespace ingress-nginx \
          --create-namespace \
          --wait \
          --timeout 10m \
          --set controller.publishService.enabled=true \
          --set controller.ingressClassResource.default=true

        kubectl get pods -n ingress-nginx

  # # ----------------------------
  # # Install Argo CD
  # # ----------------------------
  # - task: AWSShellScript@1
  #   displayName: Install Argo CD
  #   inputs:
  #     awsCredentials: $(AWS_SERVICE_CONNECTION)
  #     regionName: $(AWS_REGION)
  #     scriptType: inline
  #     inlineScript: |
  #       set -euo pipefail

  #       helm upgrade --install argocd argo/argo-cd \
  #         --namespace argocd \
  #         --create-namespace \
  #         --wait \
  #         --timeout 10m \
  #         --set server.service.type=ClusterIP \
  #         --set server.ingress.enabled=true \
  #         --set server.ingress.ingressClassName=nginx

  #       kubectl get pods -n argocd


# ----------------------------
# Install Argo CD + Ingress
# ----------------------------
- task: AWSShellScript@1
  displayName: Install Argo CD & Ingress
  inputs:
    awsCredentials: $(AWS_SERVICE_CONNECTION)
    regionName: $(AWS_REGION)
    scriptType: inline
    inlineScript: |
      set -euo pipefail

      # ----------------------------
      # Install Argo CD with Helm
      # ----------------------------
      helm upgrade --install argocd argo/argo-cd \
        --namespace argocd \
        --create-namespace \
        --wait \
        --timeout 10m \
        --set server.service.type=ClusterIP \
        --set server.ingress.enabled=false  # هيكون عندنا ingress يدوي

      # ----------------------------
      # Create Ingress for Argo CD
      # ----------------------------
      cat <<EOF | kubectl apply -f -
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      metadata:
        name: argocd-ingress
        namespace: argocd
        annotations:
          kubernetes.io/ingress.class: "nginx"
      spec:
        rules:
          - host: argocd.${ENV}.yourdomain.com   # حطي domain أو subdomain مناسب
            http:
              paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: argocd-server
                      port:
                        number: 80
      EOF

      # ----------------------------
      # Wait for Ingress IP
      # ----------------------------
      echo "Waiting for Ingress to get IP..."
      while ! kubectl get ingress argocd-ingress -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}' | grep -q '[0-9]'; do
        sleep 5
      done

      INGRESS_IP=$(kubectl get ingress argocd-ingress -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
      echo "Argo CD should be reachable at: http://${INGRESS_IP}"
