name: EKS Full Deployment Pipeline Tool
on:
  workflow_dispatch:
    inputs:
      env:
        description: Environment
        required: true
        default: prod
        type: choice
        options:
          - prod
          - nonprod

jobs:
  eks-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: eu-north-1
      ENV: ${{ github.event.inputs.env }}
      NAMESPACE: prod
      TF_DIR: terraform
      APP_PORT: 80

    steps:
    # ----------------------------
    # Checkout repo
    # ----------------------------
    - name: Checkout repo
      uses: actions/checkout@v3

    # ----------------------------
    # Install tools
    # ----------------------------
    - name: Install tools
      run: |
        set -e
        curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
        unzip -q awscliv2.zip
        sudo ./aws/install --update
        aws --version
        curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        kubectl version --client
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        helm version
    # ----------------------------
    # Setup Terraform
    # ----------------------------
    - uses: hashicorp/setup-terraform@v2

    # ----------------------------
    # Configure AWS credentials
    # ----------------------------
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # ----------------------------
    # Terraform Init & Plan
    # ----------------------------
    - name: Terraform Init
      run: terraform -chdir=${TF_DIR} init -input=false

    - name: Terraform Plan
      run: terraform -chdir=${TF_DIR} plan -var-file=${ENV}.tfvars

    # ----------------------------
    # Setup kubeconfig
    # ----------------------------
    - name: Setup kubeconfig
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
        kubectl wait --for=condition=Ready nodes --all --timeout=20m
    # ----------------------------
    # Ensure namespace
    # ----------------------------
    - name: Ensure namespace
      run: |
        kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE
    # ----------------------------
    # Add Helm repos
    # ----------------------------
    - name: Add Helm repos
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo add argo https://argoproj.github.io/argo-helm
        helm repo update
    # ----------------------------
    # Install ingress-nginx (NLB)
    # ----------------------------
    - name: Install ingress-nginx
      run: |
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          -n $NAMESPACE \
          --wait \
          --timeout 20m \
          --set controller.service.type=LoadBalancer \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
          --set controller.service.targetPorts.http=${APP_PORT}
    # ----------------------------
    # Get NLB DNS, ARN, and Listener ARN
    # ----------------------------
    - name: Get NLB and Listener ARN
      id: nlb
      run: |
        echo "Waiting for ingress-nginx NLB to be ready..."
        for i in {1..40}; do
          SERVICE_NAME=$(kubectl get svc -n $NAMESPACE -l app.kubernetes.io/name=ingress-nginx -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
          NLB_DNS=$(kubectl get svc -n $NAMESPACE $SERVICE_NAME -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
          if [ -n "$NLB_DNS" ]; then
            echo "âœ… NLB DNS ready: $NLB_DNS"
            break
          fi
          echo "â³ Waiting for NLB..."
          sleep 15
        done
        if [ -z "$NLB_DNS" ]; then
          echo "âŒ NLB DNS not found"
          exit 1
        fi
        LB_NAME=$(echo $NLB_DNS | cut -d'-' -f1)
        NLB_ARN=$(aws elbv2 describe-load-balancers --names $LB_NAME --region $AWS_REGION --query "LoadBalancers[0].LoadBalancerArn" --output text)
        if [ -z "$NLB_ARN" ]; then
          echo "âŒ NLB ARN not found"
          exit 1
        fi
        LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $NLB_ARN --region $AWS_REGION --query "Listeners[0].ListenerArn" --output text)
        if [ -z "$LISTENER_ARN" ]; then
          echo "âŒ NLB Listener ARN not found"
          exit 1
        fi
        echo "âœ… NLB Listener ARN: $LISTENER_ARN"
        echo "nlb_dns=$NLB_DNS" >> $GITHUB_OUTPUT
        echo "nlb_listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT
    # ----------------------------
    # Terraform Apply API integration (VPC_LINK â†’ NLB Listener ARN)
    # ----------------------------
    - name: Terraform Apply API integration
      run: |
        terraform -chdir=${TF_DIR} apply -auto-approve \
          -var-file=${ENV}.tfvars \
          -var="nlb_listener_arn=${{ steps.nlb.outputs.nlb_listener_arn }}" \
          -var="app_port=${APP_PORT}"
    # ----------------------------
    # Get API Gateway URL
    # ----------------------------
    - name: Get API Gateway URL
      id: api
      run: |
        API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url | tr -d '\r\n')
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "âœ… API Gateway URL: $API_URL"
   
    # ----------------------------
    # Delete old Argo CD ingress if exists
    # ----------------------------
    - name: Delete old Argo CD ingress if exists
      run: |
        if kubectl get ingress -n $NAMESPACE -l app.kubernetes.io/name=argocd-server >/dev/null 2>&1; then
          echo "ğŸ—‘ï¸ Deleting old Argo CD ingress..."
          kubectl delete ingress -n $NAMESPACE -l app.kubernetes.io/name=argocd-server
        else
          echo "âœ… No old Argo CD ingress found"
        fi
      # ----------------------------
      # Install Argo CD (Fixed Clean Version)
      # ----------------------------
    - name: Install Argo CD
      run: |
          set -euo pipefail
          
          # 1. Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„ÙƒÙ„Ø§Ø³ØªØ± Ø¨Ø¹ÙŠØ¯Ø§Ù‹ Ø¹Ù† Ø§Ù„Ù€ Wrapper Ø¨ØªØ§Ø¹ Ø§Ù„Ù€ Action Ø¹Ø´Ø§Ù† Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù…Ø®ÙÙŠØ©
          cd "${TF_DIR}"
          # Ù‡Ù†Ø³ØªØ®Ø¯Ù… terraform-bin Ù…Ø¨Ø§Ø´Ø±Ø© Ø¹Ø´Ø§Ù† Ù†Ù‡Ø±Ø¨ Ù…Ù† Ø§Ù„Ù€ debug info
          RAW_NAME=$(/usr/local/bin/terraform-bin output -raw eks_cluster_name 2>/dev/null || echo "${ENV}-eks")
          # ØªÙ†Ø¸ÙŠÙ Ø´Ø§Ù…Ù„: Ø­Ø°Ù Ø£ÙŠ Ø­Ø§Ø¬Ø© Ù…Ø´ Ø­Ø±ÙˆÙ Ø£Ùˆ Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø´Ø±Ø·Ø©
          CLUSTER_NAME=$(echo "$RAW_NAME" | sed 's/[^a-zA-Z0-9_-]//g')
          
          echo "âœ… Cleaned Cluster Name: $CLUSTER_NAME"
          
          # 2. ØªØ­Ø¯ÙŠØ« Kubeconfig
          aws eks update-kubeconfig --name "$CLUSTER_NAME" --region ${{ env.AWS_REGION }}
          
          # 3. Patch Kubeconfig
          AWS_BIN=$(which aws)
          sed -i "s|command: aws|command: $AWS_BIN|g" ~/.kube/config || true
          
          echo "ğŸš€ Installing Argo CD..."
          
          # 4. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª (Ù„Ø§Ø­Ø¸ÙŠ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙÙŠ Ø§Ù„Ù€ YAML)
          cat <<EOF > argocd-ingress-values.yaml
          server:
            extraArgs:
              - --insecure
              - --rootpath=/argocd
          EOF
          
          # 5. Ø§Ù„ØªØ«Ø¨ÙŠØª
          helm upgrade --install argocd argo-cd \
            --repo https://argoproj.github.io/argo-helm \
            --namespace $NAMESPACE --create-namespace \
            --wait --timeout 10m \
            -f argocd-ingress-values.yaml

          # 6. Ø§Ù„Ù€ Ingress
          kubectl apply -f - <<INGRESS_EOF
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: argocd-server
            namespace: $NAMESPACE
            annotations:
              nginx.ingress.kubernetes.io/backend-protocol: HTTP
          spec:
            ingressClassName: nginx
            rules:
            - http:
                paths:
                - path: /argocd
                  pathType: Prefix
                  backend:
                    service:
                      name: argocd-server
                      port:
                        number: 80
          INGRESS_EOF

    # ----------------------------
    # Install SonarQube
    # ----------------------------
    - name: Install SonarQube
        run: |
          set -euo pipefail
          cd "${TF_DIR}"
          RAW_NAME=$(/usr/local/bin/terraform-bin output -raw eks_cluster_name 2>/dev/null || echo "${ENV}-eks")
          CLUSTER_NAME=$(echo "$RAW_NAME" | sed 's/[^a-zA-Z0-9_-]//g')
          
          aws eks update-kubeconfig --name "$CLUSTER_NAME" --region ${{ env.AWS_REGION }}
          
          AWS_BIN=$(which aws)
          sed -i "s|command: aws|command: $AWS_BIN|g" ~/.kube/config || true
          
          cat <<EOF > sonarqube-values.yaml
          sonarWebContext: /sonarqube
          monitoringPasscode: "SafePasscode123"
          service:
            type: ClusterIP
          ingress:
            enabled: false
          EOF
        

          helm repo add sonarqube-repo https://SonarSource.github.io/helm-chart-sonarqube
          helm repo update
          
          helm upgrade --install sonarqube sonarqube-repo/sonarqube \
            --namespace $NAMESPACE --create-namespace \
            --wait --timeout 15m \
            -f sonarqube-values.yaml

          kubectl apply -f - <<INGRESS_EOF
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: sonarqube-ingress
            namespace: $NAMESPACE
            annotations:
              nginx.ingress.kubernetes.io/proxy-body-size: "64m"
          spec:
            ingressClassName: nginx
            rules:
            - http:
                paths:
                - path: /sonarqube
                  pathType: Prefix
                  backend:
                    service:
                      name: sonarqube-sonarqube
                      port:
                        number: 9000
          INGRESS_EOF
    # ----------------------------
    # Wait for Argo CD ingress resource ready
    # ----------------------------
    - name: Wait for Argo CD ingress
      run: |
          echo "â³ Checking Argo CD Ingress resource..."
          for i in {1..10}; do
            if kubectl get ingress -n $NAMESPACE argocd-server >/dev/null 2>&1; then
              echo "âœ… Argo CD Ingress resource found."
              break
            fi
            sleep 10
          done
    # ----------------------------
    # Show final URLs
    # ----------------------------
    - name: Show final URLs
      run: |
        echo "===================================="
        echo "âœ… API Gateway URL: ${{ steps.api.outputs.api_url }}"
        echo ""
        echo "â¡ Argo CD URL:"
        echo "http://${{ steps.nlb.outputs.nlb_dns }}/argocd"
        echo ""
        echo "â¡ SonarQube URL:"
        echo "http://${{ steps.nlb.outputs.nlb_dns }}/sonarqube"
        echo "===================================="
    



# name: EKS Full Deployment Pipeline Tool

# on:
#   workflow_dispatch:
#     inputs:
#       env:
#         description: Environment
#         required: true
#         default: prod
#         type: choice
#         options:
#           - prod
#           - nonprod

# jobs:
#   eks-deploy:
#     runs-on: ubuntu-latest
#     env:
#       AWS_REGION: eu-north-1
#       ENV: ${{ github.event.inputs.env }}
#       NAMESPACE: prod
#       TF_DIR: terraform

#     steps:
#     # ----------------------------
#     # Checkout repo
#     # ----------------------------
#     - name: Checkout repo
#       uses: actions/checkout@v3

#     # ----------------------------
#     # Install tools
#     # ----------------------------
#     - name: Install tools
#       run: |
#         set -e
#         curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
#         unzip -q awscliv2.zip
#         sudo ./aws/install --update
#         aws --version

#         curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
#         chmod +x kubectl && sudo mv kubectl /usr/local/bin/
#         kubectl version --client

#         curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
#         helm version

#     # ----------------------------
#     # Setup Terraform
#     # ----------------------------
#     - uses: hashicorp/setup-terraform@v2
#       with:
#         terraform_wrapper: false

#     # ----------------------------
#     # Configure AWS credentials
#     # ----------------------------
#     - name: Configure AWS credentials
#       uses: aws-actions/configure-aws-credentials@v2
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#         aws-region: ${{ env.AWS_REGION }}

#     # ----------------------------
#     # Terraform Init & Plan
#     # ----------------------------
#     - name: Terraform Init
#       run: terraform -chdir=${TF_DIR} init -input=false

#     - name: Terraform Plan
#       run: terraform -chdir=${TF_DIR} plan -var-file=${ENV}.tfvars

#     # ----------------------------
#     # Setup kubeconfig
#     # ----------------------------
#     - name: Setup kubeconfig
#       run: |
#         aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
#         kubectl wait --for=condition=Ready nodes --all --timeout=20m

#     # ----------------------------
#     # Ensure namespace
#     # ----------------------------
#     - name: Ensure namespace
#       run: |
#         kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

#     # ----------------------------
#     # Add Helm repos
#     # ----------------------------
#     - name: Add Helm repos
#       run: |
#         helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
#         helm repo add argo https://argoproj.github.io/argo-helm
#         helm repo update

#     # ----------------------------
#     # Install ingress-nginx
#     # ----------------------------
#     - name: Install Nginx Ingress
#       run: |
#         set -euo pipefail
#         handle_error() {
#           echo "::error:: Nginx Ingress deployment failed!"
#           kubectl get all -n $NAMESPACE
#           kubectl describe pod -l app.kubernetes.io/name=ingress-nginx -n $NAMESPACE || true
#         }
#         trap 'handle_error' ERR

#         echo "Installing Nginx Ingress Controller..."
#         helm upgrade --install ingress-nginx ingress-nginx \
#           --repo https://kubernetes.github.io/ingress-nginx \
#           --namespace $NAMESPACE --create-namespace \
#           --version 4.11.3 \
#           --set controller.service.type=LoadBalancer \
#           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
#           --set controller.admissionWebhooks.enabled=false \
#           --wait --timeout 15m
    
#     # ----------------------------
#     # Link API Gateway to Load Balancer
#     # ----------------------------
#     - name: Link API Gateway to Load Balancer
#       id: nlb_link
#       run: |
#         set -euo pipefail
#         cd "${{ env.TF_DIR }}"
        
#         echo "Fetching Load Balancer DNS..."
#         # Ø¨Ù†Ø­Ø§ÙˆÙ„ Ù†Ø¬ÙŠØ¨ Ø§Ù„Ù€ DNS Ù„Ø­Ø¯ Ù…Ø§ ÙŠØ¸Ù‡Ø±
#         for i in {1..20}; do
#           NLB_DNS=$(kubectl get svc -n $NAMESPACE -l app.kubernetes.io/instance=ingress-nginx -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' || echo "")
#           if [ -n "$NLB_DNS" ]; then break; fi
#           echo "Waiting for DNS..."
#           sleep 15
#         done

#         if [ -z "$NLB_DNS" ]; then
#           echo "::error:: Load Balancer DNS not found!"
#           exit 1
#         fi

#         echo "Found LB: $NLB_DNS"
#         NLB_NAME=$(echo $NLB_DNS | cut -d'-' -f1)
        
#         echo "Fetching LB ARN..."
#         LB_ARN=$(aws elbv2 describe-load-balancers --names "$NLB_NAME" --region ${{ env.AWS_REGION }} --query 'LoadBalancers[0].LoadBalancerArn' --output text)
        
#         echo "Fetching Listener ARN..."
#         LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn "$LB_ARN" --region ${{ env.AWS_REGION }} --query 'Listeners[0].ListenerArn' --output text)
        
#         echo "Found Listener ARN: $LISTENER_ARN"
        
#         echo "Running Terraform Apply to sync API Gateway..."
#         # Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ù‡Ù…: Ø¨Ù†Ø¨Ø¹Øª Ø§Ù„Ù€ DNS Ø¨Ø§Ù„Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ ÙˆØ§Ù„Ù€ Listener ARN
#         terraform apply -auto-approve -var-file=${{ env.ENV }}.tfvars \
#           -var="nlb_listener_arn=$LISTENER_ARN"

#     # ----------------------------
#     # Terraform Apply API integration (VPC_LINK â†’ NLB Listener ARN)
#     # ----------------------------
#     - name: Terraform Apply API integration
#       run: |
#         terraform -chdir=${TF_DIR} apply -auto-approve \
#           -var-file=${ENV}.tfvars \
#           -var="nlb_listener_arn=${{ steps.nlb.outputs.nlb_listener_arn }}"

#     # ----------------------------
#     # Get API Gateway URL
#     # ----------------------------
#     - name: Get API Gateway URL
#       id: api
#       run: |
#         RAW_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url | tr -d '\r\n')
#         echo "api_url=$(echo $RAW_URL | sed 's|/$||')" >> $GITHUB_OUTPUT

#     # ----------------------------
#     # Delete old Argo CD ingress if exists
#     # ----------------------------
#     - name: Delete old Argo CD ingress if exists
#       run: |
#         if kubectl get ingress -n $NAMESPACE -l app.kubernetes.io/name=argocd-server >/dev/null 2>&1; then
#           echo "ğŸ—‘ï¸ Deleting old Argo CD ingress..."
#           kubectl delete ingress -n $NAMESPACE -l app.kubernetes.io/name=argocd-server
#         else
#           echo "âœ… No old Argo CD ingress found"
#         fi

#     # ----------------------------
#     # Install Argo CD
#     # ----------------------------
#     - name: Install Argo CD
#       run: |
#         set -euo pipefail
        
#         # 1. Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„ÙƒÙ„Ø§Ø³ØªØ± Ù…Ù† Ù…Ø®Ø±Ø¬Ø§Øª ØªÙŠØ±ÙŠÙÙˆØ±Ù…
#         cd "${TF_DIR}"
#         CLUSTER_NAME=$(terraform output -raw eks_cluster_name 2>/dev/null || echo "${ENV}-eks")
        
#         # 2. ØªØ­Ø¯ÙŠØ« Kubeconfig
#         echo "Updating Kubeconfig for $CLUSTER_NAME..."
#         aws eks update-kubeconfig --name "$CLUSTER_NAME" --region ${{ env.AWS_REGION }}
        
#         # 3. Patch Kubeconfig (Ù„Ø¶Ù…Ø§Ù† Ø¹Ù…Ù„ Ø§Ù„Ù€ Auth Ø¨Ø´ÙƒÙ„ Ø³Ù„ÙŠÙ…)
#         AWS_BIN=$(which aws)
#         sed -i "s|command: aws|command: $AWS_BIN|g" ~/.kube/config || true
        
#         echo "Installing Argo CD..."
        
#         # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†ÙØ³ Ø§Ù„Ù‚ÙŠÙ… Ø¨Ø§Ù„Ø¸Ø¨Ø·
#         cat <<'EOF' > argocd-ingress-values.yaml
#         redis-ha:
#           enabled: false
#         controller:
#           replicas: 1
#         server:
#           replicas: 1
#           service:
#             type: ClusterIP
#           ingress:
#             enabled: false
#           extraArgs:
#             - --insecure
#             - --rootpath=/argocd
#         repoServer:
#           replicas: 1
#         applicationController:
#           replicas: 1
#         EOF
        
#         # Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª (Until loop) - Ù…Ø·Ø§Ø¨Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹
#         n=0
#         until [ "$n" -ge 3 ]
#         do
#            helm upgrade --install argocd argo-cd \
#              --repo https://argoproj.github.io/argo-helm \
#              --namespace $NAMESPACE --create-namespace \
#              --wait --timeout 10m \
#              -f argocd-ingress-values.yaml && break
#            n=$((n+1))
#            echo "Deploy failed (attempt $n/3). Retrying in 10s..."
#            helm uninstall argocd -n $NAMESPACE || true
#            sleep 20
#         done
        
#         if [ "$n" -eq 3 ]; then
#            echo "ArgoCD helm upgrade failed after 3 attempts."
#            exit 1
#         fi
        
#         echo "Applying standalone ArgoCD Ingress..."
#         kubectl apply -f - <<'INGRESS_EOF'
#         apiVersion: networking.k8s.io/v1
#         kind: Ingress
#         metadata:
#           name: argocd-server
#           namespace: ${{ env.NAMESPACE }}
#           annotations:
#             nginx.ingress.kubernetes.io/backend-protocol: HTTP
#         spec:
#           ingressClassName: nginx
#           rules:
#           - http:
#               paths:
#               - path: /argocd
#                 pathType: Prefix
#                 backend:
#                   service:
#                     name: argocd-server
#                     port:
#                       number: 80
#         INGRESS_EOF

#     # ----------------------------
#     # Install SonarQube
#     # ----------------------------
#     - name: Install SonarQube
#       run: |
#         set -euo pipefail
        
#         cd "${TF_DIR}"
#         CLUSTER_NAME=$(terraform output -raw eks_cluster_name 2>/dev/null || echo "${ENV}-eks")
#         aws eks update-kubeconfig --name "$CLUSTER_NAME" --region ${{ env.AWS_REGION }}
        
#         AWS_BIN=$(which aws)
#         sed -i "s|command: aws|command: $AWS_BIN|g" ~/.kube/config || true
        
#         echo "Installing SonarQube..."
        
#         cat > sonarqube-values.yaml <<EOF
#         monitoringPasscode: changeMe
#         community:
#           enabled: true
#         service:
#           type: ClusterIP
#         ingress:
#           enabled: true
#           ingressClassName: nginx
#           hosts:
#             - name: ""
#               path: "/sonarqube"
#           annotations:
#              nginx.ingress.kubernetes.io/proxy-body-size: "64m"
#         sonarWebContext: /sonarqube
#         EOF

#         if ! helm upgrade --install sonarqube sonarqube \
#           --repo https://SonarSource.github.io/helm-chart-sonarqube \
#           --namespace $NAMESPACE --create-namespace \
#           --wait --timeout 15m \
#           -f sonarqube-values.yaml; then
#             echo "SonarQube installation failed. Debugging..."
#             kubectl get pods -n $NAMESPACE -l app=sonarqube
#             kubectl describe pods -n $NAMESPACE -l app=sonarqube
#             kubectl logs -n $NAMESPACE -l app=sonarqube --tail=100
#             exit 1
#         fi

#     # ----------------------------
#     # Wait for Argo CD ingress resource ready
#     # ----------------------------
#     - name: Wait for Argo CD ingress
#       run: |
#         echo "â³ Waiting for Argo CD Server Pod to be ready..."
#         # Ø¨Ù†Ø³ØªÙ†Ù‰ Ø§Ù„Ù€ Pod Ù†ÙØ³Ù‡ Ø¨Ø¯Ù„ Ù…Ø§ Ù†Ø³ØªÙ†Ù‰ Ø§Ù„Ù€ Ingress Address
#         kubectl wait --namespace $NAMESPACE \
#           --for=condition=ready pod \
#           --selector=app.kubernetes.io/name=argocd-server \
#           --timeout=300s
#         echo "âœ… Argo CD Server is up and running!"
#     # ----------------------------
#     # Show final URLs
#     # ----------------------------
#     - name: Show final URLs
#       run: |
#         echo "===================================================="
#         echo "ğŸš€ Deployment Complete!"
#         echo "âœ… ArgoCD URL: ${{ steps.api.outputs.api_url }}/argocd/"
#         echo "âœ… SonarQube URL: ${{ steps.api.outputs.api_url }}/sonarqube/"
#         echo "===================================================="
#     # ----------------------------
#     # Health Check (Argo CD /argocd)
#     # ----------------------------
#     - name: Final Health Check
#       run: |
#         API_GATEWAY_URL="${{ steps.api.outputs.api_url }}"
#         echo "Testing ArgoCD via API Gateway: $API_GATEWAY_URL/argocd/"
        
#         # Ø¨Ù†Ø¬Ø±Ø¨ ÙƒØ°Ø§ Ù…Ø±Ø© Ø¹Ø´Ø§Ù† Ù„Ùˆ Ø§Ù„Ù€ API Gateway Ù„Ø³Ù‡ Ø¨ÙŠØ­Ø¯Ø« Ø§Ù„Ù€ Cache
#         for i in {1..5}; do
#           HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_GATEWAY_URL/argocd/")
#           echo "Attempt $i: Response $HTTP_STATUS"
#           if [[ "$HTTP_STATUS" == "200" || "$HTTP_STATUS" == "302" ]]; then
#             echo "âœ… ArgoCD is reachable!"
#             exit 0
#           fi
#           sleep 10
#         done
#         echo "âŒ ArgoCD is NOT reachable after 5 attempts."
#         exit 1



















# # name: EKS Full Deployment Pipeline

# # on:
# #   workflow_dispatch:
# #     inputs:
# #       env:
# #         description: Environment
# #         required: true
# #         default: prod
# #         type: choice
# #         options:
# #           - prod
# #           - nonprod

# # jobs:
# #   eks-deploy:
# #     runs-on: ubuntu-latest
# #     env:
# #       AWS_REGION: eu-north-1
# #       ENV: ${{ github.event.inputs.env }}
# #       NAMESPACE: prod
# #       TF_DIR: terraform
# #       APP_PORT: 80

# #     steps:
# #     # ----------------------------
# #     # Checkout repo
# #     # ----------------------------
# #     - name: Checkout repo
# #       uses: actions/checkout@v3

# #     # ----------------------------
# #     # Install AWS CLI, kubectl, Helm
# #     # ----------------------------
# #     - name: Install tools
# #       run: |
# #         set -e
# #         # AWS CLI
# #         curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
# #         unzip -q awscliv2.zip
# #         sudo ./aws/install --update
# #         aws --version

# #         # kubectl
# #         curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
# #         chmod +x kubectl && sudo mv kubectl /usr/local/bin/
# #         kubectl version --client

# #         # Helm
# #         curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
# #         helm version

# #     # ----------------------------
# #     # Setup Terraform
# #     # ----------------------------
# #     - uses: hashicorp/setup-terraform@v2

# #     # ----------------------------
# #     # Configure AWS credentials
# #     # ----------------------------
# #     - name: Configure AWS credentials
# #       uses: aws-actions/configure-aws-credentials@v2
# #       with:
# #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
# #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
# #         aws-region: ${{ env.AWS_REGION }}

# #     # ----------------------------
# #     # Terraform init
# #     # ----------------------------
# #     - name: Terraform Init
# #       run: terraform -chdir=${TF_DIR} init -input=false

# #     # ----------------------------
# #     # Setup kubeconfig
# #     # ----------------------------
# #     - name: Setup kubeconfig
# #       run: |
# #         aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
# #         kubectl wait --for=condition=Ready nodes --all --timeout=20m

# #     # ----------------------------
# #     # Ensure namespace
# #     # ----------------------------
# #     - name: Ensure namespace
# #       run: |
# #         kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

# #     # ----------------------------
# #     # Add Helm repos
# #     # ----------------------------
# #     - name: Add Helm repos
# #       run: |
# #         helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
# #         helm repo add argo https://argoproj.github.io/argo-helm
# #         helm repo update

# #     # ----------------------------
# #     # Install ingress-nginx (creates NLB)
# #     # ----------------------------
# #     - name: Install ingress-nginx
# #       run: |
# #         helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
# #           -n $NAMESPACE \
# #           --wait \
# #           --timeout 20m \
# #           --set controller.service.type=LoadBalancer \
# #           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
# #           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
# #           --set controller.service.targetPorts.http=${APP_PORT}

# #     # ----------------------------
# #     # Get NLB DNS
# #     # ----------------------------
# #     - name: Get NLB DNS
# #       id: nlb
# #       run: |
# #         echo "Waiting for NLB DNS..."
# #         for i in {1..20}; do
# #           DNS=$(kubectl get svc ingress-nginx-controller -n $NAMESPACE \
# #             -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
# #           if [ -n "$DNS" ]; then
# #             echo "nlb_dns=$DNS" >> $GITHUB_OUTPUT
# #             echo "âœ… Found NLB DNS: $DNS"
# #             exit 0
# #           fi
# #           sleep 30
# #         done
# #         echo "âŒ NLB DNS not found"
# #         exit 1

# #     # ----------------------------
# #     # Terraform Apply API integration
# #     # ----------------------------
# #     - name: Terraform Apply API integration
# #       run: |
# #         terraform -chdir=${TF_DIR} apply -auto-approve \
# #           -var-file=${TF_DIR}/${ENV}.tfvars \
# #           -var="integration_uri=http://${{ steps.nlb.outputs.nlb_dns }}" \
# #           -var="app_port=${APP_PORT}"

# #     # ----------------------------
# #     # Install Argo CD
# #     # ----------------------------
# #     - name: Install Argo CD
# #       run: |
# #         helm upgrade --install argocd argo/argo-cd \
# #           -n $NAMESPACE \
# #           --wait \
# #           --timeout 15m \
# #           --set server.service.type=ClusterIP \
# #           --set server.ingress.enabled=true \
# #           --set server.ingress.ingressClassName=nginx \
# #           --set server.ingress.paths[0].path="/argo(/|$)(.*)" \
# #           --set server.ingress.paths[0].pathType=Prefix \
# #           --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/rewrite-target"="/\$2"

# #     # ----------------------------
# #     # Get API Gateway URL
# #     # ----------------------------
# #     - name: Get API Gateway URL
# #       id: api
# #       run: |
# #         API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url)
# #         echo "api_url=$API_URL" >> $GITHUB_OUTPUT

# #     # ----------------------------
# #     # Health check Argo
# #     # ----------------------------
# #     - name: Check Argo CD reachable
# #       run: |
# #         echo "Checking Argo CD..."
# #         curl -f "${{ steps.api.outputs.api_url }}/argo" || exit 1

# #     # ----------------------------
# #     # Final output
# #     # ----------------------------
# #     - name: Show URLs
# #       run: |
# #         echo "=============================="
# #         echo "API Gateway URL: ${{ steps.api.outputs.api_url }}"
# #         echo "Argo CD URL: ${{ steps.api.outputs.api_url }}/argo"
# #         echo "=============================="
