name: EKS Full Deployment Pipeline Tool

on:
  workflow_dispatch:
    inputs:
      env:
        description: Environment
        required: true
        default: prod
        type: choice
        options:
          - prod
          - nonprod

jobs:
  eks-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: eu-north-1
      ENV: ${{ github.event.inputs.env }}
      NAMESPACE: prod
      TF_DIR: terraform
      APP_PORT: 80

    steps:
    # ----------------------------
    # Checkout repo
    # ----------------------------
    - name: Checkout repo
      uses: actions/checkout@v3

    # ----------------------------
    # Install AWS CLI, kubectl, Helm
    # ----------------------------
    - name: Install tools
      run: |
        set -e
        curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
        unzip -q awscliv2.zip
        sudo ./aws/install --update
        aws --version
        curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        kubectl version --client
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        helm version

    # ----------------------------
    # Setup Terraform
    # ----------------------------
    - uses: hashicorp/setup-terraform@v2

    # ----------------------------
    # Configure AWS credentials
    # ----------------------------
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # ----------------------------
    # Terraform Init & Plan
    # ----------------------------
    - name: Terraform Init
      run: terraform -chdir=${TF_DIR} init -input=false

    - name: Terraform Plan
      run: terraform -chdir=${TF_DIR} plan -var-file=${ENV}.tfvars

    # ----------------------------
    # Setup kubeconfig
    # ----------------------------
    - name: Setup kubeconfig
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
        kubectl wait --for=condition=Ready nodes --all --timeout=20m

    # ----------------------------
    # Ensure namespace
    # ----------------------------
    - name: Ensure namespace
      run: |
        kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

    # ----------------------------
    # Add Helm repos
    # ----------------------------
    - name: Add Helm repos
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo add argo https://argoproj.github.io/argo-helm
        helm repo update

    # ----------------------------
    # Install ingress-nginx (NLB)
    # ----------------------------
    - name: Install ingress-nginx
      run: |
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          -n $NAMESPACE \
          --wait \
          --timeout 20m \
          --set controller.service.type=LoadBalancer \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
          --set controller.service.targetPorts.http=${APP_PORT}

    # ----------------------------
    # Get NLB DNS with retry
    # ----------------------------
    - name: Get NLB DNS
      id: nlb
      run: |
        echo "Waiting for NLB DNS..."
        for i in {1..20}; do
          DNS=$(kubectl get svc ingress-nginx-controller -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$DNS" ]; then
            echo "nlb_dns=$DNS" >> $GITHUB_OUTPUT
            echo "✅ Found NLB DNS: $DNS"
            exit 0
          fi
          echo "Retry $i/20: NLB DNS not ready yet..."
          sleep 30
        done
        echo "❌ NLB DNS not found after retries"
        exit 1

    # ----------------------------
    # Pre-check VPC Link & Security Group
    # ----------------------------
    - name: Pre-check API VPC Link & Security Group
      run: |
        echo "Validating VPC Link and SGs..."
        VPC_LINK_ID=$(terraform -chdir=${TF_DIR} output -raw vpc_link_id 2>/dev/null | tr -d '\r\n')
        if [ -z "$VPC_LINK_ID" ]; then
          echo "❌ VPC Link not created or output missing!"
          exit 1
        fi
        echo "✅ VPC Link exists: $VPC_LINK_ID"

        SG_ID=$(terraform -chdir=${TF_DIR} output -raw vpc_link_sg_id 2>/dev/null | tr -d '\r\n')
        if [ -z "$SG_ID" ]; then
          echo "❌ VPC Link Security Group not created or output missing!"
          exit 1
        fi
        echo "✅ VPC Link SG exists: $SG_ID"

    # ----------------------------
    # Terraform Apply API integration
    # ----------------------------
    - name: Terraform Apply API integration
      run: |
        set -e
        terraform -chdir=${TF_DIR} apply -auto-approve \
          -var-file=${ENV}.tfvars \
          -var="integration_uri=http://${{ steps.nlb.outputs.nlb_dns }}" \
          -var="app_port=${APP_PORT}"

    # ----------------------------
    # Get API Gateway URL (fixed)
    # ----------------------------
    - name: Get API Gateway URL
      id: api
      run: |
        API_URL=$(terraform -chdir=${TF_DIR} output -json api_gateway_url 2>/dev/null | jq -r '. | select(.!=null) | tostring' | xargs)
        echo "DEBUG: API_URL='$API_URL'"
        if [ -z "$API_URL" ]; then
          echo "❌ API Gateway URL not found!"
          exit 1
        fi
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "✅ API Gateway URL: $API_URL"

    # ----------------------------
    # Check API Gateway reachable
    # ----------------------------
    - name: Check API Gateway reachable
      run: |
        API_URL="${{ steps.api.outputs.api_url }}"
        echo "Checking API Gateway at $API_URL"
        for i in {1..10}; do
          STATUS=$(curl -o /dev/null -s -w "%{http_code}" "$API_URL")
          if [[ "$STATUS" == "200" ]] || [[ "$STATUS" == "404" ]]; then
            echo "✅ API Gateway reachable with HTTP code $STATUS"
            exit 0
          fi
          echo "Retry $i/10: API Gateway not ready (status=$STATUS)..."
          sleep 15
        done
        echo "❌ API Gateway not reachable after retries"
        exit 1

    # ----------------------------
    # Install Argo CD
    # ----------------------------
    - name: Install Argo CD
      run: |
        helm upgrade --install argocd argo/argo-cd \
          -n $NAMESPACE \
          --wait \
          --timeout 15m \
          --set server.service.type=ClusterIP \
          --set server.ingress.enabled=true \
          --set server.ingress.ingressClassName=nginx \
          --set server.ingress.paths[0].path="/argo(/|$)(.*)" \
          --set server.ingress.paths[0].pathType=Prefix \
          --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/rewrite-target"="/\$2"

    # ----------------------------
    # Check Argo CD reachable
    # ----------------------------
    - name: Check Argo CD reachable
      run: |
        API_URL="${{ steps.api.outputs.api_url }}"
        for i in {1..10}; do
          curl -f "${API_URL}/argo" && echo "✅ Argo CD reachable" && exit 0
          echo "Retry $i/10: Argo CD not ready..."
          sleep 15
        done
        echo "❌ Argo CD not reachable after retries"
        exit 1

    # ----------------------------
    # Final output
    # ----------------------------
    - name: Show URLs
      run: |
        echo "=============================="
        echo "API Gateway URL: ${{ steps.api.outputs.api_url }}"
        echo "Argo CD URL: ${{ steps.api.outputs.api_url }}/argo"
        echo "=============================="


# name: EKS Full Deployment Pipeline

# on:
#   workflow_dispatch:
#     inputs:
#       env:
#         description: Environment
#         required: true
#         default: prod
#         type: choice
#         options:
#           - prod
#           - nonprod

# jobs:
#   eks-deploy:
#     runs-on: ubuntu-latest
#     env:
#       AWS_REGION: eu-north-1
#       ENV: ${{ github.event.inputs.env }}
#       NAMESPACE: prod
#       TF_DIR: terraform
#       APP_PORT: 80

#     steps:
#     # ----------------------------
#     # Checkout repo
#     # ----------------------------
#     - name: Checkout repo
#       uses: actions/checkout@v3

#     # ----------------------------
#     # Install AWS CLI, kubectl, Helm
#     # ----------------------------
#     - name: Install tools
#       run: |
#         set -e
#         # AWS CLI
#         curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
#         unzip -q awscliv2.zip
#         sudo ./aws/install --update
#         aws --version

#         # kubectl
#         curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
#         chmod +x kubectl && sudo mv kubectl /usr/local/bin/
#         kubectl version --client

#         # Helm
#         curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
#         helm version

#     # ----------------------------
#     # Setup Terraform
#     # ----------------------------
#     - uses: hashicorp/setup-terraform@v2

#     # ----------------------------
#     # Configure AWS credentials
#     # ----------------------------
#     - name: Configure AWS credentials
#       uses: aws-actions/configure-aws-credentials@v2
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#         aws-region: ${{ env.AWS_REGION }}

#     # ----------------------------
#     # Terraform init
#     # ----------------------------
#     - name: Terraform Init
#       run: terraform -chdir=${TF_DIR} init -input=false

#     # ----------------------------
#     # Setup kubeconfig
#     # ----------------------------
#     - name: Setup kubeconfig
#       run: |
#         aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
#         kubectl wait --for=condition=Ready nodes --all --timeout=20m

#     # ----------------------------
#     # Ensure namespace
#     # ----------------------------
#     - name: Ensure namespace
#       run: |
#         kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

#     # ----------------------------
#     # Add Helm repos
#     # ----------------------------
#     - name: Add Helm repos
#       run: |
#         helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
#         helm repo add argo https://argoproj.github.io/argo-helm
#         helm repo update

#     # ----------------------------
#     # Install ingress-nginx (creates NLB)
#     # ----------------------------
#     - name: Install ingress-nginx
#       run: |
#         helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
#           -n $NAMESPACE \
#           --wait \
#           --timeout 20m \
#           --set controller.service.type=LoadBalancer \
#           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
#           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
#           --set controller.service.targetPorts.http=${APP_PORT}

#     # ----------------------------
#     # Get NLB DNS
#     # ----------------------------
#     - name: Get NLB DNS
#       id: nlb
#       run: |
#         echo "Waiting for NLB DNS..."
#         for i in {1..20}; do
#           DNS=$(kubectl get svc ingress-nginx-controller -n $NAMESPACE \
#             -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
#           if [ -n "$DNS" ]; then
#             echo "nlb_dns=$DNS" >> $GITHUB_OUTPUT
#             echo "✅ Found NLB DNS: $DNS"
#             exit 0
#           fi
#           sleep 30
#         done
#         echo "❌ NLB DNS not found"
#         exit 1

#     # ----------------------------
#     # Terraform Apply API integration
#     # ----------------------------
#     - name: Terraform Apply API integration
#       run: |
#         terraform -chdir=${TF_DIR} apply -auto-approve \
#           -var-file=${TF_DIR}/${ENV}.tfvars \
#           -var="integration_uri=http://${{ steps.nlb.outputs.nlb_dns }}" \
#           -var="app_port=${APP_PORT}"

#     # ----------------------------
#     # Install Argo CD
#     # ----------------------------
#     - name: Install Argo CD
#       run: |
#         helm upgrade --install argocd argo/argo-cd \
#           -n $NAMESPACE \
#           --wait \
#           --timeout 15m \
#           --set server.service.type=ClusterIP \
#           --set server.ingress.enabled=true \
#           --set server.ingress.ingressClassName=nginx \
#           --set server.ingress.paths[0].path="/argo(/|$)(.*)" \
#           --set server.ingress.paths[0].pathType=Prefix \
#           --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/rewrite-target"="/\$2"

#     # ----------------------------
#     # Get API Gateway URL
#     # ----------------------------
#     - name: Get API Gateway URL
#       id: api
#       run: |
#         API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url)
#         echo "api_url=$API_URL" >> $GITHUB_OUTPUT

#     # ----------------------------
#     # Health check Argo
#     # ----------------------------
#     - name: Check Argo CD reachable
#       run: |
#         echo "Checking Argo CD..."
#         curl -f "${{ steps.api.outputs.api_url }}/argo" || exit 1

#     # ----------------------------
#     # Final output
#     # ----------------------------
#     - name: Show URLs
#       run: |
#         echo "=============================="
#         echo "API Gateway URL: ${{ steps.api.outputs.api_url }}"
#         echo "Argo CD URL: ${{ steps.api.outputs.api_url }}/argo"
#         echo "=============================="
