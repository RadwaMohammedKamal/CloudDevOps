name: EKS Full Deployment Pipeline Tool

on:
  workflow_dispatch:
    inputs:
      env:
        description: Environment
        required: true
        default: prod
        type: choice
        options:
          - prod
          - nonprod

jobs:
  eks-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: eu-north-1
      ENV: ${{ github.event.inputs.env }}
      NAMESPACE: prod
      TF_DIR: terraform

    steps:
    # ----------------------------
    # Checkout repo
    # ----------------------------
    - name: Checkout repo
      uses: actions/checkout@v3

    # ----------------------------
    # Install tools
    # ----------------------------
    - name: Install tools
      run: |
        set -e
        curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
        unzip -q awscliv2.zip
        sudo ./aws/install --update
        aws --version

        curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        kubectl version --client

        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        helm version

    # ----------------------------
    # Setup Terraform
    # ----------------------------
    - uses: hashicorp/setup-terraform@v2

    # ----------------------------
    # Configure AWS credentials
    # ----------------------------
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # ----------------------------
    # Terraform Init & Plan
    # ----------------------------
    - name: Terraform Init
      run: terraform -chdir=${TF_DIR} init -input=false

    - name: Terraform Plan
      run: terraform -chdir=${TF_DIR} plan -var-file=${ENV}.tfvars

    # ----------------------------
    # Setup kubeconfig
    # ----------------------------
    - name: Setup kubeconfig
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
        kubectl wait --for=condition=Ready nodes --all --timeout=20m

    # ----------------------------
    # Ensure namespace
    # ----------------------------
    - name: Ensure namespace
      run: |
        kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

    # ----------------------------
    # Add Helm repos
    # ----------------------------
    - name: Add Helm repos
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo add argo https://argoproj.github.io/argo-helm
        helm repo update

    # ----------------------------
    # Install ingress-nginx (Advanced Logic)
    # ----------------------------
    - name: Install ingress-nginx
      run: |
        set -euo pipefail
        
        # Function to run on failure (Debug mode)
        handle_error() {
          echo "::error:: Nginx Ingress deployment failed!"
          echo "Fetching debug logs..."
          kubectl get all -n $NAMESPACE
          kubectl describe pod -l app.kubernetes.io/name=ingress-nginx -n $NAMESPACE || true
          kubectl logs -l app.kubernetes.io/name=ingress-nginx -n $NAMESPACE --all-containers --tail=100 || true
          kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' || true
        }
        
        # Set up trap to call handle_error on script failure
        trap 'handle_error' ERR

        echo "Installing Nginx Ingress Controller..."
        # Ø§Ø³ØªØ®Ø¯Ù…Ù†Ø§ Ø§Ù„Ù€ Namespace Ø¨ØªØ§Ø¹ Ø§Ù„Ø¨Ø§ÙŠØ¨Ù„Ø§ÙŠÙ† Ø¨ØªØ§Ø¹ØªÙƒ ÙˆØ§Ù„Ù€ Logic Ø¨ØªØ§Ø¹Ù‡ Ù‡Ùˆ ÙÙŠ Ø§Ù„Ù€ Upgrade
        helm upgrade --install ingress-nginx ingress-nginx \
          --repo https://kubernetes.github.io/ingress-nginx \
          --namespace $NAMESPACE --create-namespace \
          --version 4.11.3 \
          --set controller.service.type=LoadBalancer \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
          --set controller.admissionWebhooks.enabled=false \
          --wait \
          --timeout 15m \
          --debug

    # ----------------------------
    # Get NLB DNS, ARN, and Listener ARN
    # ----------------------------
    - name: Get NLB and Listener ARN
      id: nlb
      run: |
        echo "Waiting for ingress-nginx NLB to be ready..."
        for i in {1..40}; do
          SERVICE_NAME=$(kubectl get svc -n $NAMESPACE -l app.kubernetes.io/name=ingress-nginx -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
          NLB_DNS=$(kubectl get svc -n $NAMESPACE $SERVICE_NAME -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
          if [ -n "$NLB_DNS" ]; then
            echo "âœ… NLB DNS ready: $NLB_DNS"
            break
          fi
          echo "â³ Waiting for NLB..."
          sleep 15
        done
        if [ -z "$NLB_DNS" ]; then
          echo "âŒ NLB DNS not found"
          exit 1
        fi
        LB_NAME=$(echo $NLB_DNS | cut -d'-' -f1)
        NLB_ARN=$(aws elbv2 describe-load-balancers --names $LB_NAME --region $AWS_REGION --query "LoadBalancers[0].LoadBalancerArn" --output text)
        if [ -z "$NLB_ARN" ]; then
          echo "âŒ NLB ARN not found"
          exit 1
        fi
        LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $NLB_ARN --region $AWS_REGION --query "Listeners[0].ListenerArn" --output text)
        if [ -z "$LISTENER_ARN" ]; then
          echo "âŒ NLB Listener ARN not found"
          exit 1
        fi
        echo "âœ… NLB Listener ARN: $LISTENER_ARN"
        echo "nlb_dns=$NLB_DNS" >> $GITHUB_OUTPUT
        echo "nlb_listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT

    # ----------------------------
    # Terraform Apply API integration (VPC_LINK â†’ NLB Listener ARN)
    # ----------------------------
    - name: Terraform Apply API integration
      run: |
        terraform -chdir=${TF_DIR} apply -auto-approve \
          -var-file=${ENV}.tfvars \
          -var="nlb_listener_arn=${{ steps.nlb.outputs.nlb_listener_arn }}"

    # ----------------------------
    # Get API Gateway URL
    # ----------------------------
    - name: Get API Gateway URL
      id: api
      run: |
        API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url | tr -d '\r\n')
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "âœ… API Gateway URL: $API_URL"

   
    # ----------------------------
    # Delete old Argo CD ingress if exists
    # ----------------------------
    - name: Delete old Argo CD ingress if exists
      run: |
        if kubectl get ingress -n $NAMESPACE -l app.kubernetes.io/name=argocd-server >/dev/null 2>&1; then
          echo "ğŸ—‘ï¸ Deleting old Argo CD ingress..."
          kubectl delete ingress -n $NAMESPACE -l app.kubernetes.io/name=argocd-server
        else
          echo "âœ… No old Argo CD ingress found"
        fi

    # ----------------------------
    # Install Argo CD (Ù…Ø·Ø§Ø¨Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹ Ù„Ù„ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠ Ø¨Ø¹ØªÙŠÙ‡)
    # ----------------------------
    - name: Install Argo CD
      run: |
        set -euo pipefail
        
        # 1. Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„ÙƒÙ„Ø§Ø³ØªØ± Ù…Ù† Ù…Ø®Ø±Ø¬Ø§Øª ØªÙŠØ±ÙŠÙÙˆØ±Ù…
        cd "${TF_DIR}"
        CLUSTER_NAME=$(terraform output -raw cluster_name || echo "${ENV}-eks")
        
        # 2. ØªØ­Ø¯ÙŠØ« Kubeconfig
        echo "Updating Kubeconfig for $CLUSTER_NAME..."
        aws eks update-kubeconfig --name "$CLUSTER_NAME" --region ${{ env.AWS_REGION }}
        
        # 3. Patch Kubeconfig (Ù„Ø¶Ù…Ø§Ù† Ø¹Ù…Ù„ Ø§Ù„Ù€ Auth Ø¨Ø´ÙƒÙ„ Ø³Ù„ÙŠÙ…)
        AWS_BIN=$(which aws)
        sed -i "s|command: aws|command: $AWS_BIN|g" ~/.kube/config || true
        
        echo "Installing Argo CD..."
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†ÙØ³ Ø§Ù„Ù‚ÙŠÙ… Ø¨Ø§Ù„Ø¸Ø¨Ø·
        cat <<'EOF' > argocd-ingress-values.yaml
        redis-ha:
          enabled: false
        controller:
          replicas: 1
        server:
          replicas: 1
          service:
            type: ClusterIP
          ingress:
            enabled: false
          extraArgs:
            - --insecure
            - --rootpath=/argocd
        repoServer:
          replicas: 1
        applicationController:
          replicas: 1
        EOF
        
        # Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª (Until loop) - Ù…Ø·Ø§Ø¨Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹
        n=0
        until [ "$n" -ge 3 ]
        do
           helm upgrade --install argocd argo-cd \
             --repo https://argoproj.github.io/argo-helm \
             --namespace $NAMESPACE --create-namespace \
             --wait --timeout 10m \
             -f argocd-ingress-values.yaml && break
           n=$((n+1))
           echo "Deploy failed (attempt $n/3). Retrying in 10s..."
           helm uninstall argocd -n $NAMESPACE || true
           sleep 20
        done
        
        if [ "$n" -eq 3 ]; then
           echo "ArgoCD helm upgrade failed after 3 attempts."
           exit 1
        fi
        
        echo "Applying standalone ArgoCD Ingress..."
        kubectl apply -f - <<'INGRESS_EOF'
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: argocd-server
          namespace: ${{ env.NAMESPACE }}
          annotations:
            nginx.ingress.kubernetes.io/backend-protocol: HTTP
        spec:
          ingressClassName: nginx
          rules:
          - http:
              paths:
              - path: /argocd
                pathType: Prefix
                backend:
                  service:
                    name: argocd-server
                    port:
                      number: 80
        INGRESS_EOF

    # ----------------------------
    # Install SonarQube (Ù…Ø·Ø§Ø¨Ù‚ ØªÙ…Ø§Ù…Ø§Ù‹ Ù„Ù„ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠ Ø¨Ø¹ØªÙŠÙ‡)
    # ----------------------------
    - name: Install SonarQube
      run: |
        set -euo pipefail
        
        cd "${TF_DIR}"
        CLUSTER_NAME=$(terraform output -raw cluster_name || echo "${ENV}-eks")
        aws eks update-kubeconfig --name "$CLUSTER_NAME" --region ${{ env.AWS_REGION }}
        
        AWS_BIN=$(which aws)
        sed -i "s|command: aws|command: $AWS_BIN|g" ~/.kube/config || true
        
        echo "Installing SonarQube..."
        
        cat > sonarqube-values.yaml <<EOF
        monitoringPasscode: changeMe
        community:
          enabled: true
        service:
          type: ClusterIP
        ingress:
          enabled: true
          ingressClassName: nginx
          hosts:
            - name: ""
              path: "/sonarqube"
          annotations:
             nginx.ingress.kubernetes.io/proxy-body-size: "64m"
        sonarWebContext: /sonarqube
        EOF

        if ! helm upgrade --install sonarqube sonarqube \
          --repo https://SonarSource.github.io/helm-chart-sonarqube \
          --namespace $NAMESPACE --create-namespace \
          --wait --timeout 15m \
          -f sonarqube-values.yaml; then
            echo "SonarQube installation failed. Debugging..."
            kubectl get pods -n $NAMESPACE -l app=sonarqube
            kubectl describe pods -n $NAMESPACE -l app=sonarqube
            kubectl logs -n $NAMESPACE -l app=sonarqube --tail=100
            exit 1
        fi

    # ----------------------------
    # Wait for Argo CD ingress resource ready
    # ----------------------------
    - name: Wait for Argo CD ingress
      run: |
        for i in {1..20}; do
          INGRESS=$(kubectl get ingress -n $NAMESPACE -l app.kubernetes.io/name=argocd-server -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
          if [ -n "$INGRESS" ]; then
            echo "âœ… Argo CD Ingress ready: $INGRESS"
            break
          fi
          echo "â³ Waiting for Argo CD Ingress..."
          sleep 15
        done

    # ----------------------------
    # Health Check (Argo CD /argo)
    # ----------------------------
    - name: Final Health Check
      run: |
        API_GATEWAY_URL="${{ steps.api.outputs.api_url }}"
        echo "Testing ArgoCD via API Gateway: $API_GATEWAY_URL/argocd/"
        
        # Ø¨Ù†Ø¬Ø±Ø¨ ÙƒØ°Ø§ Ù…Ø±Ø© Ø¹Ø´Ø§Ù† Ù„Ùˆ Ø§Ù„Ù€ API Gateway Ù„Ø³Ù‡ Ø¨ÙŠØ­Ø¯Ø« Ø§Ù„Ù€ Cache
        for i in {1..5}; do
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_GATEWAY_URL/argocd/")
          echo "Attempt $i: Response $HTTP_STATUS"
          if [[ "$HTTP_STATUS" == "200" || "$HTTP_STATUS" == "302" ]]; then
            echo "âœ… ArgoCD is reachable!"
            exit 0
          fi
          sleep 10
        done
        echo "âŒ ArgoCD is NOT reachable after 5 attempts."
        exit 1
    # ----------------------------
    # Show final URLs
    # ----------------------------
    - name: Show final URLs
      run: |
        echo "===================================================="
        echo "ğŸš€ Deployment Complete!"
        echo "âœ… ArgoCD URL: ${{ steps.api.outputs.api_url }}/argocd/"
        echo "âœ… SonarQube URL: ${{ steps.api.outputs.api_url }}/sonarqube/"
        echo "===================================================="



# - name: Get NLB and Listener ARN
#       id: nlb
#       run: |
#         echo "Waiting for ingress-nginx NLB to be ready..."
#         for i in {1..40}; do
#           SERVICE_NAME=$(kubectl get svc -n $NAMESPACE -l app.kubernetes.io/name=ingress-nginx -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
#           NLB_DNS=$(kubectl get svc -n $NAMESPACE $SERVICE_NAME -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
#           if [ -n "$NLB_DNS" ]; then
#             echo "âœ… NLB DNS ready: $NLB_DNS"
#             break
#           fi
#           echo "â³ Waiting for NLB..."
#           sleep 15
#         done

#         if [ -z "$NLB_DNS" ]; then
#           echo "âŒ NLB DNS not found"
#           exit 1
#         fi

#         LB_NAME=$(echo $NLB_DNS | cut -d'-' -f1)
#         NLB_ARN=$(aws elbv2 describe-load-balancers --names $LB_NAME --region $AWS_REGION --query "LoadBalancers[0].LoadBalancerArn" --output text)
#         if [ -z "$NLB_ARN" ]; then
#           echo "âŒ NLB ARN not found"
#           exit 1
#         fi

#         LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $NLB_ARN --region $AWS_REGION --query "Listeners[0].ListenerArn" --output text)
#         if [ -z "$LISTENER_ARN" ]; then
#           echo "âŒ NLB Listener ARN not found"
#           exit 1
#         fi

#         echo "âœ… NLB Listener ARN: $LISTENER_ARN"
#         echo "nlb_dns=$NLB_DNS" >> $GITHUB_OUTPUT
#         echo "nlb_listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT

# name: EKS Full Deployment Pipeline Tool

# on:
#   workflow_dispatch:
#     inputs:
#       env:
#         description: Environment
#         required: true
#         default: prod
#         type: choice
#         options:
#           - prod
#           - nonprod

# jobs:
#   eks-deploy:
#     runs-on: ubuntu-latest
#     env:
#       AWS_REGION: eu-north-1
#       ENV: ${{ github.event.inputs.env }}
#       NAMESPACE: prod
#       TF_DIR: terraform
#       APP_PORT: 80

#     steps:
#     # ----------------------------
#     # Checkout repo
#     # ----------------------------
#     - name: Checkout repo
#       uses: actions/checkout@v3

#     # ----------------------------
#     # Install tools
#     # ----------------------------
#     - name: Install tools
#       run: |
#         set -e
#         curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
#         unzip -q awscliv2.zip
#         sudo ./aws/install --update
#         aws --version

#         curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
#         chmod +x kubectl && sudo mv kubectl /usr/local/bin/
#         kubectl version --client

#         curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
#         helm version

#     # ----------------------------
#     # Setup Terraform
#     # ----------------------------
#     - uses: hashicorp/setup-terraform@v2

#     # ----------------------------
#     # Configure AWS credentials
#     # ----------------------------
#     - name: Configure AWS credentials
#       uses: aws-actions/configure-aws-credentials@v2
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#         aws-region: ${{ env.AWS_REGION }}

#     # ----------------------------
#     # Terraform Init & Plan
#     # ----------------------------
#     - name: Terraform Init
#       run: terraform -chdir=${TF_DIR} init -input=false

#     - name: Terraform Plan
#       run: terraform -chdir=${TF_DIR} plan -var-file=${ENV}.tfvars

#     # ----------------------------
#     # Setup kubeconfig
#     # ----------------------------
#     - name: Setup kubeconfig
#       run: |
#         aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
#         kubectl wait --for=condition=Ready nodes --all --timeout=20m

#     # ----------------------------
#     # Ensure namespace
#     # ----------------------------
#     - name: Ensure namespace
#       run: |
#         kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

#     # ----------------------------
#     # Add Helm repos
#     # ----------------------------
#     - name: Add Helm repos
#       run: |
#         helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
#         helm repo add argo https://argoproj.github.io/argo-helm
#         helm repo update

#     # ----------------------------
#     # Install ingress-nginx (NLB)
#     # ----------------------------
#     - name: Install ingress-nginx
#       run: |
#         helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
#           -n $NAMESPACE \
#           --wait \
#           --timeout 20m \
#           --set controller.service.type=LoadBalancer \
#           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
#           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
#           --set controller.service.targetPorts.http=${APP_PORT}

#     # ----------------------------
#     # Get NLB DNS and Listener ARN
#     # ----------------------------
#     - name: Get NLB and Listener ARN
#       id: nlb
#       run: |
#         SERVICE_NAME="ingress-nginx-controller"

#         echo "Waiting for NLB DNS to be available..."
#         NLB_DNS=""
#         for i in {1..40}; do
#           NLB_DNS=$(kubectl get svc -n $NAMESPACE $SERVICE_NAME -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
#           if [ -n "$NLB_DNS" ]; then
#             echo "âœ… NLB DNS found: $NLB_DNS"
#             break
#           fi
#           echo "Waiting 15s..."
#           sleep 15
#         done

#         if [ -z "$NLB_DNS" ]; then
#           echo "âŒ NLB DNS not found after 10 min"
#           exit 1
#         fi

#         LB_NAME=$(echo $NLB_DNS | cut -d'-' -f1)
#         NLB_ARN=$(aws elbv2 describe-load-balancers \
#           --names $LB_NAME \
#           --region $AWS_REGION \
#           --query 'LoadBalancers[0].LoadBalancerArn' \
#           --output text)

#         LISTENER_ARN=""
#         for i in {1..20}; do
#           LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $NLB_ARN --region $AWS_REGION --query 'Listeners[0].ListenerArn' --output text || echo "")
#           if [ -n "$LISTENER_ARN" ]; then
#             echo "âœ… Listener ARN found: $LISTENER_ARN"
#             break
#           fi
#           echo "Waiting 15s for listener..."
#           sleep 15
#         done

#         if [ -z "$LISTENER_ARN" ]; then
#           echo "âŒ Listener ARN not found!"
#           exit 1
#         fi

#         echo "nlb_dns=$NLB_DNS" >> $GITHUB_OUTPUT
#         echo "listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT

#     # ----------------------------
#     # Terraform Apply API integration
#     # ----------------------------
#     - name: Terraform Apply API integration
#       run: |
#         terraform -chdir=${TF_DIR} apply -auto-approve \
#           -var-file=${ENV}.tfvars \
#           -var="nlb_listener_arn=${{ steps.nlb.outputs.listener_arn }}" \
#           -var="app_port=${APP_PORT}"

#     # ----------------------------
#     # Get API Gateway URL (cleaned)
#     # ----------------------------
#     - name: Get API Gateway URL
#       id: api
#       run: |
#         API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url | tr -d '\r\n' | xargs)
#         echo "api_url=$API_URL" >> $GITHUB_OUTPUT
#         echo "âœ… API Gateway URL: $API_URL"

#     # ----------------------------
#     # Install Argo CD (HTTP, /argo)
#     # ----------------------------
#     - name: Install Argo CD
#       run: |
#         helm upgrade --install argocd argo/argo-cd \
#           -n $NAMESPACE \
#           --wait \
#           --timeout 15m \
#           --set server.service.type=ClusterIP \
#           --set server.ingress.enabled=true \
#           --set server.ingress.ingressClassName=nginx \
#           --set server.ingress.hosts[0].host="argocd.example.com" \
#           --set server.ingress.hosts[0].paths[0].path="/argo" \
#           --set server.ingress.hosts[0].paths[0].pathType=Prefix \
#           --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/rewrite-target"="/\$2" \
#           --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/ssl-redirect"="false"

#     # ----------------------------
#     # Show final URLs
#     # ----------------------------
#     - name: Show final URLs
#       run: |
#         echo "===================================="
#         echo "âœ… API Gateway URL (APP):"
#         echo "${{ steps.api.outputs.api_url }}"
#         echo ""
#         echo "âœ… Argo CD URL (HTTP):"
#         echo "http://${{ steps.nlb.outputs.nlb_dns }}/argo"
#         echo "===================================="















# # name: EKS Full Deployment Pipeline

# # on:
# #   workflow_dispatch:
# #     inputs:
# #       env:
# #         description: Environment
# #         required: true
# #         default: prod
# #         type: choice
# #         options:
# #           - prod
# #           - nonprod

# # jobs:
# #   eks-deploy:
# #     runs-on: ubuntu-latest
# #     env:
# #       AWS_REGION: eu-north-1
# #       ENV: ${{ github.event.inputs.env }}
# #       NAMESPACE: prod
# #       TF_DIR: terraform
# #       APP_PORT: 80

# #     steps:
# #     # ----------------------------
# #     # Checkout repo
# #     # ----------------------------
# #     - name: Checkout repo
# #       uses: actions/checkout@v3

# #     # ----------------------------
# #     # Install AWS CLI, kubectl, Helm
# #     # ----------------------------
# #     - name: Install tools
# #       run: |
# #         set -e
# #         # AWS CLI
# #         curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
# #         unzip -q awscliv2.zip
# #         sudo ./aws/install --update
# #         aws --version

# #         # kubectl
# #         curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
# #         chmod +x kubectl && sudo mv kubectl /usr/local/bin/
# #         kubectl version --client

# #         # Helm
# #         curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
# #         helm version

# #     # ----------------------------
# #     # Setup Terraform
# #     # ----------------------------
# #     - uses: hashicorp/setup-terraform@v2

# #     # ----------------------------
# #     # Configure AWS credentials
# #     # ----------------------------
# #     - name: Configure AWS credentials
# #       uses: aws-actions/configure-aws-credentials@v2
# #       with:
# #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
# #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
# #         aws-region: ${{ env.AWS_REGION }}

# #     # ----------------------------
# #     # Terraform init
# #     # ----------------------------
# #     - name: Terraform Init
# #       run: terraform -chdir=${TF_DIR} init -input=false

# #     # ----------------------------
# #     # Setup kubeconfig
# #     # ----------------------------
# #     - name: Setup kubeconfig
# #       run: |
# #         aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
# #         kubectl wait --for=condition=Ready nodes --all --timeout=20m

# #     # ----------------------------
# #     # Ensure namespace
# #     # ----------------------------
# #     - name: Ensure namespace
# #       run: |
# #         kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

# #     # ----------------------------
# #     # Add Helm repos
# #     # ----------------------------
# #     - name: Add Helm repos
# #       run: |
# #         helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
# #         helm repo add argo https://argoproj.github.io/argo-helm
# #         helm repo update

# #     # ----------------------------
# #     # Install ingress-nginx (creates NLB)
# #     # ----------------------------
# #     - name: Install ingress-nginx
# #       run: |
# #         helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
# #           -n $NAMESPACE \
# #           --wait \
# #           --timeout 20m \
# #           --set controller.service.type=LoadBalancer \
# #           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
# #           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
# #           --set controller.service.targetPorts.http=${APP_PORT}

# #     # ----------------------------
# #     # Get NLB DNS
# #     # ----------------------------
# #     - name: Get NLB DNS
# #       id: nlb
# #       run: |
# #         echo "Waiting for NLB DNS..."
# #         for i in {1..20}; do
# #           DNS=$(kubectl get svc ingress-nginx-controller -n $NAMESPACE \
# #             -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
# #           if [ -n "$DNS" ]; then
# #             echo "nlb_dns=$DNS" >> $GITHUB_OUTPUT
# #             echo "âœ… Found NLB DNS: $DNS"
# #             exit 0
# #           fi
# #           sleep 30
# #         done
# #         echo "âŒ NLB DNS not found"
# #         exit 1

# #     # ----------------------------
# #     # Terraform Apply API integration
# #     # ----------------------------
# #     - name: Terraform Apply API integration
# #       run: |
# #         terraform -chdir=${TF_DIR} apply -auto-approve \
# #           -var-file=${TF_DIR}/${ENV}.tfvars \
# #           -var="integration_uri=http://${{ steps.nlb.outputs.nlb_dns }}" \
# #           -var="app_port=${APP_PORT}"

# #     # ----------------------------
# #     # Install Argo CD
# #     # ----------------------------
# #     - name: Install Argo CD
# #       run: |
# #         helm upgrade --install argocd argo/argo-cd \
# #           -n $NAMESPACE \
# #           --wait \
# #           --timeout 15m \
# #           --set server.service.type=ClusterIP \
# #           --set server.ingress.enabled=true \
# #           --set server.ingress.ingressClassName=nginx \
# #           --set server.ingress.paths[0].path="/argo(/|$)(.*)" \
# #           --set server.ingress.paths[0].pathType=Prefix \
# #           --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/rewrite-target"="/\$2"

# #     # ----------------------------
# #     # Get API Gateway URL
# #     # ----------------------------
# #     - name: Get API Gateway URL
# #       id: api
# #       run: |
# #         API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url)
# #         echo "api_url=$API_URL" >> $GITHUB_OUTPUT

# #     # ----------------------------
# #     # Health check Argo
# #     # ----------------------------
# #     - name: Check Argo CD reachable
# #       run: |
# #         echo "Checking Argo CD..."
# #         curl -f "${{ steps.api.outputs.api_url }}/argo" || exit 1

# #     # ----------------------------
# #     # Final output
# #     # ----------------------------
# #     - name: Show URLs
# #       run: |
# #         echo "=============================="
# #         echo "API Gateway URL: ${{ steps.api.outputs.api_url }}"
# #         echo "Argo CD URL: ${{ steps.api.outputs.api_url }}/argo"
# #         echo "=============================="
