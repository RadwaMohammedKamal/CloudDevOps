name: EKS Full Deployment Pipeline Tool

on:
  workflow_dispatch:
    inputs:
      env:
        description: Environment
        required: true
        default: prod
        type: choice
        options:
          - prod
          - nonprod

jobs:
  eks-deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: eu-north-1
      ENV: ${{ github.event.inputs.env }}
      NAMESPACE: prod
      TF_DIR: terraform
      APP_PORT: 80

    steps:
    # ----------------------------
    # Checkout repo
    # ----------------------------
    - name: Checkout repo
      uses: actions/checkout@v3

    # ----------------------------
    # Install tools
    # ----------------------------
    - name: Install tools
      run: |
        set -e
        curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
        unzip -q awscliv2.zip
        sudo ./aws/install --update
        aws --version

        curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
        chmod +x kubectl && sudo mv kubectl /usr/local/bin/
        kubectl version --client

        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        helm version

    # ----------------------------
    # Setup Terraform
    # ----------------------------
    - uses: hashicorp/setup-terraform@v2

    # ----------------------------
    # Configure AWS credentials
    # ----------------------------
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # ----------------------------
    # Terraform Init & Plan
    # ----------------------------
    - name: Terraform Init
      run: terraform -chdir=${TF_DIR} init -input=false

    - name: Terraform Plan
      run: terraform -chdir=${TF_DIR} plan -var-file=${ENV}.tfvars

    # ----------------------------
    # Setup kubeconfig
    # ----------------------------
    - name: Setup kubeconfig
      run: |
        aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
        kubectl wait --for=condition=Ready nodes --all --timeout=20m

    # ----------------------------
    # Ensure namespace
    # ----------------------------
    - name: Ensure namespace
      run: |
        kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

    # ----------------------------
    # Add Helm repos
    # ----------------------------
    - name: Add Helm repos
      run: |
        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
        helm repo add argo https://argoproj.github.io/argo-helm
        helm repo update

    # ----------------------------
    # Install ingress-nginx (NLB)
    # ----------------------------
    - name: Install ingress-nginx
      run: |
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
          -n $NAMESPACE \
          --wait \
          --timeout 20m \
          --set controller.service.type=LoadBalancer \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
          --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
          --set controller.service.targetPorts.http=${APP_PORT}

    # ----------------------------
    # Get NLB ARN & Listener ARN
    # ----------------------------
    - name: Get NLB Listener ARN
      id: nlb_listener
      run: |
        NLB_NAME="ingress-nginx-controller"
        NLB_ARN=$(aws elbv2 describe-load-balancers --names $NLB_NAME \
          --query "LoadBalancers[0].LoadBalancerArn" --output text)
        if [ -z "$NLB_ARN" ]; then
          echo "❌ NLB ARN not found"
          exit 1
        fi
        LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $NLB_ARN \
          --query "Listeners[0].ListenerArn" --output text)
        if [ -z "$LISTENER_ARN" ]; then
          echo "❌ NLB Listener ARN not found"
          exit 1
        fi
        echo "✅ NLB Listener ARN: $LISTENER_ARN"
        echo "nlb_listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT

    # ----------------------------
    # Terraform Apply (API Gateway → NLB Listener ARN)
    # ----------------------------
    - name: Terraform Apply API integration
      run: |
        terraform -chdir=${TF_DIR} apply -auto-approve \
          -var-file=${ENV}.tfvars \
          -var="nlb_listener_arn=${{ steps.nlb_listener.outputs.nlb_listener_arn }}"

    # ----------------------------
    # Get API Gateway URL
    # ----------------------------
    - name: Get API Gateway URL
      id: api
      run: |
        API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url | tr -d '\r\n')
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "✅ API Gateway URL: $API_URL"

    # ----------------------------
    # Install Argo CD (values.yaml)
    # ----------------------------
    - name: Install Argo CD
      run: |
        helm upgrade --install argocd argo/argo-cd \
          -n $NAMESPACE \
          --wait \
          --timeout 15m \
          -f k8s/argocd/values.yaml

    # ----------------------------
    # Health Check (Argo CD)
    # ----------------------------
    - name: Argo CD Health Check
      run: |
        echo "Checking Argo CD readiness..."
        for i in {1..20}; do
          STATUS=$(kubectl get pods -n $NAMESPACE -l app.kubernetes.io/name=argocd-server \
            -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "")
          if [ "$STATUS" == "Running" ]; then
            echo "✅ Argo CD Server is Running"
            exit 0
          fi
          echo "⏳ Waiting for Argo CD Server..."
          sleep 15
        done
        echo "❌ Argo CD Server failed to start"
        kubectl describe pods -n $NAMESPACE -l app.kubernetes.io/name=argocd-server
        exit 1

    # ----------------------------
    # Rollback-safe validation (Ingress)
    # ----------------------------
    - name: Validate Argo CD Ingress
      run: |
        NLB_HOST=$(kubectl get svc -n $NAMESPACE ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "Testing Argo CD path..."
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$NLB_HOST/argo")
        if [ "$HTTP_STATUS" != "200" ] && [ "$HTTP_STATUS" != "302" ]; then
          echo "❌ Argo CD ingress test failed: HTTP $HTTP_STATUS"
          exit 1
        fi
        echo "✅ Argo CD ingress test passed: HTTP $HTTP_STATUS"

    # ----------------------------
    # Show final URLs
    # ----------------------------
    - name: Show final URLs
      run: |
        echo "===================================="
        echo "✅ API Gateway URL:"
        echo "${{ steps.api.outputs.api_url }}"
        echo ""
        echo "➡ Argo CD URL:"
        echo "http://$(kubectl get svc -n $NAMESPACE ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')/argo"
        echo "===================================="



# name: EKS Full Deployment Pipeline Tool

# on:
#   workflow_dispatch:
#     inputs:
#       env:
#         description: Environment
#         required: true
#         default: prod
#         type: choice
#         options:
#           - prod
#           - nonprod

# jobs:
#   eks-deploy:
#     runs-on: ubuntu-latest
#     env:
#       AWS_REGION: eu-north-1
#       ENV: ${{ github.event.inputs.env }}
#       NAMESPACE: prod
#       TF_DIR: terraform
#       APP_PORT: 80

#     steps:
#     # ----------------------------
#     # Checkout repo
#     # ----------------------------
#     - name: Checkout repo
#       uses: actions/checkout@v3

#     # ----------------------------
#     # Install tools
#     # ----------------------------
#     - name: Install tools
#       run: |
#         set -e
#         curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
#         unzip -q awscliv2.zip
#         sudo ./aws/install --update
#         aws --version

#         curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
#         chmod +x kubectl && sudo mv kubectl /usr/local/bin/
#         kubectl version --client

#         curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
#         helm version

#     # ----------------------------
#     # Setup Terraform
#     # ----------------------------
#     - uses: hashicorp/setup-terraform@v2

#     # ----------------------------
#     # Configure AWS credentials
#     # ----------------------------
#     - name: Configure AWS credentials
#       uses: aws-actions/configure-aws-credentials@v2
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#         aws-region: ${{ env.AWS_REGION }}

#     # ----------------------------
#     # Terraform Init & Plan
#     # ----------------------------
#     - name: Terraform Init
#       run: terraform -chdir=${TF_DIR} init -input=false

#     - name: Terraform Plan
#       run: terraform -chdir=${TF_DIR} plan -var-file=${ENV}.tfvars

#     # ----------------------------
#     # Setup kubeconfig
#     # ----------------------------
#     - name: Setup kubeconfig
#       run: |
#         aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
#         kubectl wait --for=condition=Ready nodes --all --timeout=20m

#     # ----------------------------
#     # Ensure namespace
#     # ----------------------------
#     - name: Ensure namespace
#       run: |
#         kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

#     # ----------------------------
#     # Add Helm repos
#     # ----------------------------
#     - name: Add Helm repos
#       run: |
#         helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
#         helm repo add argo https://argoproj.github.io/argo-helm
#         helm repo update

#     # ----------------------------
#     # Install ingress-nginx (NLB)
#     # ----------------------------
#     - name: Install ingress-nginx
#       run: |
#         helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
#           -n $NAMESPACE \
#           --wait \
#           --timeout 20m \
#           --set controller.service.type=LoadBalancer \
#           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
#           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
#           --set controller.service.targetPorts.http=${APP_PORT}

#     # ----------------------------
#     # Get NLB DNS and Listener ARN
#     # ----------------------------
#     - name: Get NLB and Listener ARN
#       id: nlb
#       run: |
#         SERVICE_NAME="ingress-nginx-controller"

#         echo "Waiting for NLB DNS to be available..."
#         NLB_DNS=""
#         for i in {1..40}; do
#           NLB_DNS=$(kubectl get svc -n $NAMESPACE $SERVICE_NAME -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
#           if [ -n "$NLB_DNS" ]; then
#             echo "✅ NLB DNS found: $NLB_DNS"
#             break
#           fi
#           echo "Waiting 15s..."
#           sleep 15
#         done

#         if [ -z "$NLB_DNS" ]; then
#           echo "❌ NLB DNS not found after 10 min"
#           exit 1
#         fi

#         LB_NAME=$(echo $NLB_DNS | cut -d'-' -f1)
#         NLB_ARN=$(aws elbv2 describe-load-balancers \
#           --names $LB_NAME \
#           --region $AWS_REGION \
#           --query 'LoadBalancers[0].LoadBalancerArn' \
#           --output text)

#         LISTENER_ARN=""
#         for i in {1..20}; do
#           LISTENER_ARN=$(aws elbv2 describe-listeners --load-balancer-arn $NLB_ARN --region $AWS_REGION --query 'Listeners[0].ListenerArn' --output text || echo "")
#           if [ -n "$LISTENER_ARN" ]; then
#             echo "✅ Listener ARN found: $LISTENER_ARN"
#             break
#           fi
#           echo "Waiting 15s for listener..."
#           sleep 15
#         done

#         if [ -z "$LISTENER_ARN" ]; then
#           echo "❌ Listener ARN not found!"
#           exit 1
#         fi

#         echo "nlb_dns=$NLB_DNS" >> $GITHUB_OUTPUT
#         echo "listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT

#     # ----------------------------
#     # Terraform Apply API integration
#     # ----------------------------
#     - name: Terraform Apply API integration
#       run: |
#         terraform -chdir=${TF_DIR} apply -auto-approve \
#           -var-file=${ENV}.tfvars \
#           -var="nlb_listener_arn=${{ steps.nlb.outputs.listener_arn }}" \
#           -var="app_port=${APP_PORT}"

#     # ----------------------------
#     # Get API Gateway URL (cleaned)
#     # ----------------------------
#     - name: Get API Gateway URL
#       id: api
#       run: |
#         API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url | tr -d '\r\n' | xargs)
#         echo "api_url=$API_URL" >> $GITHUB_OUTPUT
#         echo "✅ API Gateway URL: $API_URL"

#     # ----------------------------
#     # Install Argo CD (HTTP, /argo)
#     # ----------------------------
#     - name: Install Argo CD
#       run: |
#         helm upgrade --install argocd argo/argo-cd \
#           -n $NAMESPACE \
#           --wait \
#           --timeout 15m \
#           --set server.service.type=ClusterIP \
#           --set server.ingress.enabled=true \
#           --set server.ingress.ingressClassName=nginx \
#           --set server.ingress.hosts[0].host="argocd.example.com" \
#           --set server.ingress.hosts[0].paths[0].path="/argo" \
#           --set server.ingress.hosts[0].paths[0].pathType=Prefix \
#           --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/rewrite-target"="/\$2" \
#           --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/ssl-redirect"="false"

#     # ----------------------------
#     # Show final URLs
#     # ----------------------------
#     - name: Show final URLs
#       run: |
#         echo "===================================="
#         echo "✅ API Gateway URL (APP):"
#         echo "${{ steps.api.outputs.api_url }}"
#         echo ""
#         echo "✅ Argo CD URL (HTTP):"
#         echo "http://${{ steps.nlb.outputs.nlb_dns }}/argo"
#         echo "===================================="















# # name: EKS Full Deployment Pipeline

# # on:
# #   workflow_dispatch:
# #     inputs:
# #       env:
# #         description: Environment
# #         required: true
# #         default: prod
# #         type: choice
# #         options:
# #           - prod
# #           - nonprod

# # jobs:
# #   eks-deploy:
# #     runs-on: ubuntu-latest
# #     env:
# #       AWS_REGION: eu-north-1
# #       ENV: ${{ github.event.inputs.env }}
# #       NAMESPACE: prod
# #       TF_DIR: terraform
# #       APP_PORT: 80

# #     steps:
# #     # ----------------------------
# #     # Checkout repo
# #     # ----------------------------
# #     - name: Checkout repo
# #       uses: actions/checkout@v3

# #     # ----------------------------
# #     # Install AWS CLI, kubectl, Helm
# #     # ----------------------------
# #     - name: Install tools
# #       run: |
# #         set -e
# #         # AWS CLI
# #         curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
# #         unzip -q awscliv2.zip
# #         sudo ./aws/install --update
# #         aws --version

# #         # kubectl
# #         curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
# #         chmod +x kubectl && sudo mv kubectl /usr/local/bin/
# #         kubectl version --client

# #         # Helm
# #         curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
# #         helm version

# #     # ----------------------------
# #     # Setup Terraform
# #     # ----------------------------
# #     - uses: hashicorp/setup-terraform@v2

# #     # ----------------------------
# #     # Configure AWS credentials
# #     # ----------------------------
# #     - name: Configure AWS credentials
# #       uses: aws-actions/configure-aws-credentials@v2
# #       with:
# #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
# #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
# #         aws-region: ${{ env.AWS_REGION }}

# #     # ----------------------------
# #     # Terraform init
# #     # ----------------------------
# #     - name: Terraform Init
# #       run: terraform -chdir=${TF_DIR} init -input=false

# #     # ----------------------------
# #     # Setup kubeconfig
# #     # ----------------------------
# #     - name: Setup kubeconfig
# #       run: |
# #         aws eks update-kubeconfig --region $AWS_REGION --name "${ENV}-eks"
# #         kubectl wait --for=condition=Ready nodes --all --timeout=20m

# #     # ----------------------------
# #     # Ensure namespace
# #     # ----------------------------
# #     - name: Ensure namespace
# #       run: |
# #         kubectl get ns $NAMESPACE || kubectl create ns $NAMESPACE

# #     # ----------------------------
# #     # Add Helm repos
# #     # ----------------------------
# #     - name: Add Helm repos
# #       run: |
# #         helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
# #         helm repo add argo https://argoproj.github.io/argo-helm
# #         helm repo update

# #     # ----------------------------
# #     # Install ingress-nginx (creates NLB)
# #     # ----------------------------
# #     - name: Install ingress-nginx
# #       run: |
# #         helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
# #           -n $NAMESPACE \
# #           --wait \
# #           --timeout 20m \
# #           --set controller.service.type=LoadBalancer \
# #           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
# #           --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
# #           --set controller.service.targetPorts.http=${APP_PORT}

# #     # ----------------------------
# #     # Get NLB DNS
# #     # ----------------------------
# #     - name: Get NLB DNS
# #       id: nlb
# #       run: |
# #         echo "Waiting for NLB DNS..."
# #         for i in {1..20}; do
# #           DNS=$(kubectl get svc ingress-nginx-controller -n $NAMESPACE \
# #             -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
# #           if [ -n "$DNS" ]; then
# #             echo "nlb_dns=$DNS" >> $GITHUB_OUTPUT
# #             echo "✅ Found NLB DNS: $DNS"
# #             exit 0
# #           fi
# #           sleep 30
# #         done
# #         echo "❌ NLB DNS not found"
# #         exit 1

# #     # ----------------------------
# #     # Terraform Apply API integration
# #     # ----------------------------
# #     - name: Terraform Apply API integration
# #       run: |
# #         terraform -chdir=${TF_DIR} apply -auto-approve \
# #           -var-file=${TF_DIR}/${ENV}.tfvars \
# #           -var="integration_uri=http://${{ steps.nlb.outputs.nlb_dns }}" \
# #           -var="app_port=${APP_PORT}"

# #     # ----------------------------
# #     # Install Argo CD
# #     # ----------------------------
# #     - name: Install Argo CD
# #       run: |
# #         helm upgrade --install argocd argo/argo-cd \
# #           -n $NAMESPACE \
# #           --wait \
# #           --timeout 15m \
# #           --set server.service.type=ClusterIP \
# #           --set server.ingress.enabled=true \
# #           --set server.ingress.ingressClassName=nginx \
# #           --set server.ingress.paths[0].path="/argo(/|$)(.*)" \
# #           --set server.ingress.paths[0].pathType=Prefix \
# #           --set server.ingress.annotations."nginx\.ingress\.kubernetes\.io/rewrite-target"="/\$2"

# #     # ----------------------------
# #     # Get API Gateway URL
# #     # ----------------------------
# #     - name: Get API Gateway URL
# #       id: api
# #       run: |
# #         API_URL=$(terraform -chdir=${TF_DIR} output -raw api_gateway_url)
# #         echo "api_url=$API_URL" >> $GITHUB_OUTPUT

# #     # ----------------------------
# #     # Health check Argo
# #     # ----------------------------
# #     - name: Check Argo CD reachable
# #       run: |
# #         echo "Checking Argo CD..."
# #         curl -f "${{ steps.api.outputs.api_url }}/argo" || exit 1

# #     # ----------------------------
# #     # Final output
# #     # ----------------------------
# #     - name: Show URLs
# #       run: |
# #         echo "=============================="
# #         echo "API Gateway URL: ${{ steps.api.outputs.api_url }}"
# #         echo "Argo CD URL: ${{ steps.api.outputs.api_url }}/argo"
# #         echo "=============================="
